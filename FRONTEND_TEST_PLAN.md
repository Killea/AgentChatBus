# AgentChatBus 前端综合测试规划

**文档版本：** 1.0  
**生成日期：** 2026-03-01  
**负责人：** Copilot Frontend Tester

---

## 目录
1. [执行摘要](#执行摘要)
2. [测试用例总览](#测试用例总览)
3. [优先级分类详细场景](#优先级分类详细场景)
4. [测试数据准备](#测试数据准备)
5. [Mock/Stub 策略](#mockstub-策略)
6. [执行环境需求](#执行环境需求)
7. [验收标准](#验收标准)

---

## 执行摘要

### 项目现状
- **现有测试：** 7 个烟雾测试（覆盖率 ~10-15%）
- **组件数量：** 13 个 Web Components
- **核心模块：** 11 个 shared-*.js 模块  
- **关键缺口：** 5 大类共 50+ 个测试场景

### 提议的测试分层
```
┌─────────────────────────────────────┐
│      E2E 测试（完整用户流）          │ 8-12 cases
│   (多 Agent, 并发, 长连接)           │
├─────────────────────────────────────┤
│   集成测试（组件 + API）             │ 20-25 cases
│  (SSE, 消息同步, 状态管理)           │
├─────────────────────────────────────┤
│    单元测试（模块隔离）              │ 15-20 cases
│   (shared-*.js 纯函数测试)           │
├─────────────────────────────────────┤
│    现有烟雾测试（回归）              │ 7 cases
│      (维持现状)                      │
└─────────────────────────────────────┘
```

### 预期工作量
- **测试用例总数：** ~60 个
- **预期代码行数：** 2500-3500 行
- **分类：** 单元(15), 集成(25), E2E(10), 烟雾(7), 并发(3)

---

## 测试用例总览

### 优先级矩阵

| 优先级 | 类别 | 风险等级 | 复杂度 | 估计用例数 |
|------|------|--------|------|----------|
| 🔴 P0 | SSE 连接 | 极高 | 高 | 8 |
| 🔴 P0 | 消息同步 | 极高 | 高 | 10 |
| 🟠 P1 | 组件交互 | 高 | 中 | 12 |
| 🟠 P1 | Agent 状态 | 高 | 中 | 8 |
| 🟡 P2 | UI 状态 | 中 | 低 | 10 |
| 🟡 P2 | 错误恢复 | 中 | 高 | 7 |
| 🟢 P3 | 边界情况 | 低 | 低 | 5 |
| ⚪ 回归 | 烟雾测试 | N/A | 低 | 7 |

---

## 优先级分类详细场景

### 🔴 P0 - SSE 长连接稳定性 (8 cases)

#### TC-SSE-001: SSE 连接初始化成功
- **分类:** 连接建立
- **优先级:** P0 - 必要条件
- **复杂度:** 低
- **前置条件:**
  - 服务器已启动
  - 前端页面已加载
  - `/events` 端点可用
- **步骤:**
  1. 页面加载时初始化 SSE 连接
  2. 监听 `EventSource` 的 `onopen` 事件
  3. 检查状态指示器变为绿色 ("Connected")
- **预期输出:**
  - SSE 连接建立
  - 状态 dot 显示绿色
  - 无浏览器控制台错误
- **边界情况:**
  - 网络延迟 > 5s
  - 服务器响应缓慢
- **验证点:**
  - `document.getElementById("status-label").textContent === "Connected"`
  - `window.eventSource.readyState === EventSource.OPEN`

#### TC-SSE-002: SSE 自动重连机制
- **分类:** 连接恢复
- **优先级:** P0 - 核心保障
- **复杂度:** 高
- **前置条件:**
  - SSE 连接已建立
  - 服务器 `/events` 模拟断线
- **步骤:**
  1. 正常连接状态下，模拟服务器断线 (close 连接)
  2. 等待浏览器触发 `onerror` 回调
  3. 验证重连计时器启动 (延迟 3000ms)
  4. 验证 5-10 秒内重新建立连接
- **预期输出:**
  - 连接暂时中断时，状态变为红色 ("Reconnecting…")
  - 3-5 秒后自动重连
  - 重连后状态恢复绿色
- **边界情况:**
  - 连续断线 3 次以上
  - 重连时间超过阈值 (20s)
- **验证点:**
  - 状态标签在断线时显示 "Reconnecting…"
  - 无手动干预下自动恢复

#### TC-SSE-003: 长连接下消息实时推送
- **分类:** 实时数据
- **优先级:** P0 - 核心功能
- **复杂度:** 中
- **前置条件:**
  - SSE 连接已建立
  - Thread 已选中
  - 有其他 Agent 在线
- **步骤:**
  1. Agent A 在 Thread 发送消息
  2. 前端 onmessage 处理事件 (type: `msg.new`)
  3. 验证消息立即出现在 UI (< 500ms)
  4. 验证消息顺序正确 (seq 递增)
- **预期输出:**
  - 消息在发送后 500ms 内显示
  - seq 号正确递增
  - 消息作者、角色正确展示
- **边界情况:**
  - 多个消息快速连续发送 (< 100ms)
  - 大消息 (> 10KB) 推送
  - 网络延迟 > 1s
- **验证点:**
  - `.msg-row` 元素按 seq 顺序排列
  - 消息数量与后台一致

#### TC-SSE-004: SSE 事件类型处理 - msg.new
- **分类:** 事件处理
- **优先级:** P0
- **复杂度:** 中
- **前置条件:** SSE 连接建立
- **步骤:**
  1. 通过 API 发送消息到 Thread
  2. SSE 推送 `msg.new` 事件
  3. 验证触发 `onMsgNew()` 回调
  4. 验证其他 Thread 的 `onThreadEvent()` 也被触发
- **预期输出:**
  - 当前 Thread 中消息立即刷新
  - 其他 Thread 列表更新最后消息预览
- **验证点:**
  - 消息计数增加
  - 最后消息时间戳更新

#### TC-SSE-005: SSE 事件类型处理 - thread.state
- **分类:** 事件处理
- **优先级:** P0
- **复杂度:** 中
- **前置条件:** 多个 Thread 列表可见
- **步骤:**
  1. 通过 API 更改 Thread 状态 (discuss → review)
  2. SSE 推送 `thread.state` 事件
  3. 验证 UI 中 Thread 状态标签更新
- **预期输出:**
  - Thread 状态标签从 "discuss" 变为 "review"
  - 线程列表刷新
- **验证点:**
  - `thread-item` 中的状态章节正确更新

#### TC-SSE-006: SSE 事件类型处理 - agent.presence
- **分类:** 事件处理
- **优先级:** P0
- **复杂度:** 中
- **前置条件:** 至少 2 个 Agent 在线
- **步骤:**
  1. Agent B 心跳超时离线
  2. SSE 推送 `agent.presence` 事件
  3. 验证 Agent 状态栏中 Agent B 变为灰色/离线
- **预期输出:**
  - Agent B 的在线指示灯变红
  - Agent B 在 `window.agent_presence` 中标记为离线
- **验证点:**
  - `acb-agent-status-item` 中 Agent B 的状态变为 "offline"

#### TC-SSE-007: 高频事件处理（压力测试）
- **分类:** 性能
- **优先级:** P0
- **复杂度:** 高
- **前置条件:** SSE 连接建立
- **步骤:**
  1. 模拟 10 条消息在 1 秒内推送
  2. 验证 UI 反应时间
  3. 检查是否有消息丢失/顺序错乱
  4. 监控浏览器性能 (CPU, 内存)
- **预期输出:**
  - 所有 10 条消息最终显示
  - 消息顺序未变
  - 页面响应 < 200ms
  - 内存增长 < 5MB
- **边界情况:**
  - 消息大小 > 50KB
  - 同时多 Thread 推送
- **验证点:**
  - 无 JavaScript 错误
  - `.msg-row.count()` === 10

#### TC-SSE-008: SSE 连接下线程归档事件
- **分类:** 事件处理
- **优先级:** P0
- **复杂度:** 中
- **前置条件:** Thread 列表可见
- **步骤:**
  1. 通过 API 归档一个 Thread
  2. SSE 推送 `thread.archived` 事件
  3. 验证 Thread 从活跃列表消失
  4. 验证可通过"包含已归档"过滤再次看到
- **预期输出:**
  - 已归档线程不显示在默认列表
  - 状态按钮更新反映归档
- **验证点:**
  - `thread-item` 从 DOM 中移除

---

### 🔴 P0 - 消息同步与顺序保证 (10 cases)

#### TC-MSG-001: 单条消息发送与显示同步
- **分类:** 核心流程
- **优先级:** P0 - 必要条件
- **复杂度:** 低
- **前置条件:**
  - 选中一个 Thread
  - 输入框（acb-compose-shell）可见
- **步骤:**
  1. 在输入框输入文本 "Test message 001"
  2. 点击发送按钮或按 Ctrl+Enter
  3. 等待消息 API 响应
  4. 验证消息在 UI 中显示
  5. 验证 seq 号递增
- **预期输出:**
  - 消息出现在消息列表
  - `author` 为当前用户 "human"
  - `role` 为 "user"
  - `seq` > 上一条消息的 seq
- **边界情况:**
  - 空消息发送
  - 消息包含特殊字符 (emoji, HTML 标签)
  - 消息 > 10,000 字符
- **验证点:**
  - `.msg-row` 新增一条记录
  - 消息内容正确转义显示

#### TC-MSG-002: 多消息顺序保证（无乱序）
- **分类:** 数据完整性
- **优先级:** P0 - 关键
- **复杂度:** 中
- **前置条件:** Thread 已选中
- **步骤:**
  1. 发送 5 条消息，间隔 100ms
  2. 记录每条消息的 seq 号
  3. 验证 seq 严格递增
  4. 验证显示顺序与 seq 一致
- **预期输出:**
  - seq: 100, 101, 102, 103, 104
  - UI 显示顺序不变
  - 无重复 seq
- **边界情况:**
  - 并发发送 (同时发送，不等待响应)
  - 消息大小差异大 (1B vs 10KB)
- **验证点:**
  - `Array.from(page.locator(".msg-row")).map(e => e.getAttribute("data-seq"))`
    所有值按升序

#### TC-MSG-003: 消息分页加载（Thread 切换后）
- **分类:** 性能优化
- **优先级:** P0
- **复杂度:** 低
- **前置条件:**
  - 存在多个 Thread，每个 Thread 有多条消息
- **步骤:**
  1. Thread A 选中，加载消息 (limit=300)
  2. 切换至 Thread B
  3. 验证 Thread B 的消息列表被清空后重新加载
  4. 验证新消息集合正确且顺序正确
- **预期输出:**
  - Thread B 消息从 0 重新加载到最新 seq
  - 消息总数 ≤ 300
  - 显示最近的 300 条消息
- **边界情况:**
  - Thread 有 > 1000 条消息
  - 消息加载时切换回原 Thread
- **验证点:**
  - `#messages` 容器的消息数量正确

#### TC-MSG-004: 新消息 SSE 推送与本地消息合并
- **分类:** 实时同步
- **优先级:** P0
- **复杂度:** 高
- **前置条件:**
  - 2+ Agents 在同一 Thread
  - SSE 连接建立
- **步骤:**
  1. Agent A 本地发送消息
  2. Agent B 同时发送消息
  3. SSE 推送 Agent B 的消息 (msg.new)
  4. 验证两条消息最终都显示
  5. 验证消息顺序正确 (按 seq)
- **预期输出:**
  - 两条消息都显示在 UI
  - 顺序由 seq 决定，与谁先按下发送无关
  - 最终 UI 与后端数据库一致
- **边界情况:**
  - 极短时间内 (< 50ms) 多条消息
  - 一方消息发送失败
- **验证点:**
  - 无消息重复
  - 无消息遗漏
  - seq 单调递增

#### TC-MSG-005: 消息编辑与版本管理
- **分类:** 数据持久化
- **优先级:** P0
- **复杂度:** 中
- **前置条件:**
  - 存在可编辑的消息 (角色为 user/assistant)
- **步骤:**
  1. 选择一条已发送的消息
  2. 编辑内容并提交
  3. 验证后端更新 (通过 API)
  4. 验证 SSE 推送编辑事件
  5. 验证 UI 中消息内容更新
- **预期输出:**
  - 消息内容变更
  - seq 号不变 (同一消息)
  - 展示编辑时间戳 "edited at ..."
- **边界情况:**
  - 编辑为空内容
  - 编辑期间其他 Agent 也在操作
  - 网络错误导致编辑失败
- **验证点:**
  - API 编辑响应成功
  - UI 反映变更

#### TC-MSG-006: 消息删除与 UI 同步
- **分类:** 数据管理
- **优先级:** P0
- **复杂度:** 低
- **前置条件:** 消息可删除
- **步骤:**
  1. 选择消息右键菜单 → 删除
  2. 确认删除
  3. 验证消息从 UI 移除
  4. 验证 seq 间隙 (deleted seq 号不重用)
- **预期输出:**
  - 消息行（msg-row）从 DOM 移除
  - 消息序号间隙保留
  - 生成删除日志事件
- **边界情况:**
  - 删除最后一条消息
  - 删除后消息列表为空
  - 删除期间 SSE 推送新消息
- **验证点:**
  - `.msg-row[data-seq="X"]` 不存在

#### TC-MSG-007: 系统消息与用户消息混合显示
- **分类:** 内容渲染
- **优先级:** P0
- **复杂度:** 低
- **前置条件:** Thread 包含系统和用户消息
- **步骤:**
  1. 加载包含 system role 的消息
  2. 验证系统消息样式与用户消息不同
  3. 验证消息顺序按 seq 不变
  4. 验证系统消息内容正确展示
- **预期输出:**
  - 系统消息显示特殊样式 (灰色/淡化)
  - author 清晰标识为 "system"
  - 内容完整转义
- **验证点:**
  - `.msg-row .role-badge` 显示 "system"

#### TC-MSG-008: 消息渲染性能 (大消息列表)
- **分类:** 性能
- **优先级:** P0
- **复杂度:** 高
- **前置条件:** 加载 > 500 条消息
- **步骤:**
  1. API 返回 500 条消息
  2. 页面加载消息列表
  3. 测量渲染时间
  4. 测量内存使用
  5. 滚动列表，验证帧率
- **预期输出:**
  - 初始渲染 < 2秒
  - 内存占用 < 50MB
  - 滚动时帧率 > 30fps
  - 无 JavaScript 错误
- **边界情况:**
  - 消息包含大量 HTML/emoji
  - 网络延迟情况下加载
- **验证点:**
  - `performance.measure()` 时间 < 2s
  - Chrome DevTools 内存快照 < 50MB

#### TC-MSG-009: 消息搜索与过滤
- **分类:** 查询功能
- **优先级:** P0
- **复杂度:** 中
- **前置条件:** Thread 有消息
- **步骤:**
  1. 打开消息搜索框
  2. 输入关键词（如 "test"）
  3. 验证返回包含关键词的消息
  4. 验证突出显示匹配项
- **预期输出:**
  - 搜索结果过滤正确
  - 匹配项高亮显示
  - 结果数量正确
- **验证点:**
  - 搜索结果 DOM 更新

#### TC-MSG-010: 消息持久化与离线恢复
- **分类:** 数据恢复
- **优先级:** P0
- **复杂度:** 中
- **前置条件:** 页面刷新能保留消息历史
- **步骤:**
  1. 加载 Thread A，记录消息 seq
  2. 刷新页面
  3. 重新选中 Thread A
  4. 验证消息完全恢复
- **预期输出:**
  - 消息列表与刷新前一致
  - seq 号完整无丢失
  - 未读状态正确保留
- **验证点:**
  - 消息数量一致
  - 最后 seq 号一致

---

### 🟠 P1 - 组件交互与 Web Components 测试 (12 cases)

#### TC-COMP-001: acb-compose-shell - 消息输入框基础功能
- **分类:** 用户界面
- **优先级:** P1
- **复杂度:** 低
- **前置条件:**
  - Thread 已选中
  - compose-shell 组件加载
- **步骤:**
  1. 点击输入框获得焦点
  2. 输入文本 "Hello World"
  3. 验证文本出现在输入框
  4. 点击发送按钮
  5. 验证输入框被清空
- **预期输出:**
  - 输入框获得焦点后边框变蓝
  - 文本可输入且显示正确
  - 发送后输入框内容清空
  - 消息发送
- **验证点:**
  - `.compose-input` 的值清空
  - API POST 调用成功

#### TC-COMP-002: acb-compose-shell - 快捷键发送（Ctrl+Enter）
- **分类:** 快捷操作
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** compose-shell 获得焦点
- **步骤:**
  1. 输入文本
  2. 按 Ctrl+Enter (或 Cmd+Enter)
  3. 验证消息发送
- **预期输出:**
  - 消息发送
  - 输入框清空
- **验证点:**
  - 消息出现在列表

#### TC-COMP-003: acb-compose-shell - 多行文本支持
- **分类:** 功能扩展
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** compose-shell 可用
- **步骤:**
  1. 输入多行文本（回车分行）
  2. 验证输入框高度自动调整
  3. 发送消息
  4. 验证多行内容保留
- **预期输出:**
  - 输入框随内容扩展高度
  - 消息包含换行符
  - 显示时换行保留
- **验证点:**
  - 消息内容中 `\n` 正确显示

#### TC-COMP-004: acb-thread-item - 线程列表项点击选择
- **分类:** 导航
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** 线程列表可见，有多个线程
- **步骤:**
  1. 点击 thread-item（线程 B）
  2. 验证线程 B 被选中（高亮）
  3. 验证消息列表切换为线程 B 的消息
- **预期输出:**
  - thread-item 添加 `.active` 类
  - 消息列表加载线程 B 的消息
  - thread-header 更新为线程 B 的标题
- **验证点:**
  - `#thread-pane .thread-item.active` 指向正确的线程
  - 消息数量改变

#### TC-COMP-005: acb-thread-item - 线程右键菜单
- **分类:** 操作菜单
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** thread-item 可见
- **步骤:**
  1. 右键点击 thread-item
  2. 验证上下文菜单出现
  3. 菜单应包含：删除、归档、重命名等选项
  4. 点击删除
  5. 验证确认对话框出现
- **预期输出:**
  - acb-thread-context-menu 弹出
  - 包含正确的操作菜单项
  - 执行操作成功
- **验证点:**
  - context menu 显示
  - 菜单项功能正确

#### TC-COMP-006: acb-modal-shell - 通用模态框生命周期
- **分类:** UI 组件
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** 模态框组件存在
- **步骤:**
  1. 打开模态框（例如新建 Thread）
  2. 验证 overlay 显示
  3. 验证模态框内容可交互
  4. 点击 X 按钮关闭
  5. 验证模态框和 overlay 隐藏
- **预期输出:**
  - overlay 的 opacity 变为 1
  - 模态框显示
  - 关闭后 display: none
- **边界情况:**
  - 按 ESC 关闭
  - 点击 overlay 背景关闭
- **验证点:**
  - `.visible` 类的添加/移除

#### TC-COMP-007: acb-confirm-dialog - 删除确认对话框
- **分类:** 用户确认
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** 触发删除操作
- **步骤:**
  1. 触发删除 Thread 操作
  2. confirm-dialog 出现
  3. 验证文本："确实要删除吗？"
  4. 点击"确认"按钮
  5. 验证删除执行
  6. 点击"取消"验证删除被阻止
- **预期输出:**
  - 对话框显示正确提示文本
  - 确认删除时执行 API 调用
  - 取消时无变更
- **验证点:**
  - DELETE API 被调用或未被调用

#### TC-COMP-008: acb-agent-status-item - Agent 单项状态显示
- **分类:** 状态展示
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** Agent 状态栏可见
- **步骤:**
  1. 验证在线 Agent 显示绿色指示灯
  2. 验证离线 Agent 显示红色指示灯
  3. 验证 Agent 名称和角色显示
  4. 悬停 Agent 项查看完整信息
- **预期输出:**
  - 在线状态用绿色指示
  - 离线状态用红色指示
  - tooltip 显示详细信息
- **验证点:**
  - `data-status` 属性值正确
  - 样式应用正确

#### TC-COMP-009: acb-agent-status-shell - Agent 状态栏更新
- **分类:** 实时更新
- **优先级:** P1
- **复杂度:** 中
- **前置条件:**
  - 2+ Agents 在线
  - SSE 连接建立
- **步骤:**
  1. 观察 Agent 状态栏
  2. Agent B 从在线变离线（心跳超时）
  3. SSE 推送 `agent.presence` 事件
  4. 验证 Agent B 的状态立即更新为离线
  5. Agent B 重新上线时状态更新为在线
- **预期输出:**
  - 状态栏实时反映 Agent 状态变更
  - 状态变更延迟 < 1s
- **验证点:**
  - agent-status-item 中的颜色变更
  - 没有页面显示延迟

#### TC-COMP-010: acb-thread-filter-shell - 线程过滤功能
- **分类:** 过滤控制
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** 线程列表有不同状态的线程
- **步骤:**
  1. 打开过滤面板（Filter button）
  2. 取消选择 "archived" 复选框
  3. 验证已归档线程从列表消失
  4. 再次选中 "archived"
  5. 验证已归档线程重新出现
- **预期输出:**
  - 过滤面板显示所有可用状态
  - 未选中的状态线程被隐藏
  - 过滤状态保存
- **验证点:**
  - thread-item 的显隐与过滤条件一致

#### TC-COMP-011: acb-empty-state - 空状态占位符
- **分类:** 状态反馈
- **优先级:** P1
- **复杂度:** 低
- **前置条件:**
  - 无 Thread 选中，或 Thread 无消息
- **步骤:**
  1. 清空所有消息
  2. 验证 empty-state 组件显示
  3. 显示文本：如 "No messages yet"
  4. 发送第一条消息
  5. 验证 empty-state 消失
- **预期输出:**
  - empty-state 在消息列表为空时显示
  - 消息出现后立即隐藏
- **验证点:**
  - `#messages .empty-state.visible` 状态正确

#### TC-COMP-012: acb-icon-button - 通用图标按钮组件
- **分类:** 基础组件
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** 页面有多个 icon-button
- **步骤:**
  1. 点击各个 icon-button（新建、设置、主题等）
  2. 验证点击事件触发
  3. 验证 hover 样式应用
  4. 验证禁用状态（如果存在）
- **预期输出:**
  - 点击触发预期的操作
  - hover 颜色变浅
  - disabled 状态下按钮不可点击
- **验证点:**
  - 对应的操作执行（打开模态框、切换主题等）

---

### 🟠 P1 - Agent 在线状态与 Presence 管理 (8 cases)

#### TC-AGENT-001: Agent 注册与在线状态初始化
- **分类:** 身份管理
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** 新 Agent 尚未注册
- **步骤:**
  1. 新 Agent 调用 `agent_register` MCP 工具
  2. 返回 agent_id 和 token
  3. 验证 Agent 在 UI 的 Agent 状态栏出现
  4. 验证初始状态为在线（绿色）
  5. 验证其他 Agent 通过 SSE 收到 agent.presence 事件
- **预期输出:**
  - UI 中 agent-status-item 新增
  - Agent 状态为在线
  - 其他用户能看到新 Agent
- **验证点:**
  - `window.agent_presence[agent_id]` === "online"
  - acb-agent-status-shell 中包含新 Agent

#### TC-AGENT-002: Agent 心跳与在线状态维持
- **分类:** 连接保活
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** Agent 已注册
- **步骤:**
  1. Agent 每 30 秒发送一次心跳 `agent_heartbeat`
  2. 观察 Agent 状态在 UI 保持在线
  3. 停止心跳 30+ 秒
  4. 验证 Agent 状态变为离线
- **预期输出:**
  - 心跳期间状态始终在线
  - 无心跳 > 心跳超时 (30s) 后状态变离线
- **验证点:**
  - 无 heartbeat 后 `is_online` 变为 false

#### TC-AGENT-003: Agent 上线事件广播
- **分类:** 事件通知
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** SSE 连接已建立
- **步骤:**
  1. 新 Agent 注册
  2. SSE 广播 `agent.presence` 事件 (type: "online")
  3. 验证所有连接的客户端收到事件
  4. 验证 UI 中所有客户端立即更新显示该 Agent
- **预期输出:**
  - 所有客户端的 Agent 状态栏同步更新
  - 新 Agent 在所有 UI 中显示在线
- **验证点:**
  - 多客户端的 agent-status-shell 同步

#### TC-AGENT-004: Agent 离线事件广播
- **分类:** 事件通知
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** Agent 在线，然后心跳超时
- **步骤:**
  1. Agent B 断开连接（无心跳 > 30s）
  2. SSE 广播 `agent.presence` 事件 (type: "offline")
  3. 验证所有客户端更新 Agent B 为离线
- **预期输出:**
  - Agent B 的状态指示灯变红
  - 所有客户端同步更新
- **验证点:**
  - 没有手动刷新页面的情况下状态更新

#### TC-AGENT-005: Agent 恢复上线
- **分类:** 状态恢复
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** Agent 处于离线状态
- **步骤:**
  1. 离线的 Agent 重新发送心跳
  2. Agent 标记为在线
  3. SSE 广播上线事件
  4. 验证 UI 中 Agent 状态恢复为在线
- **预期输出:**
  - Agent 状态灯变绿
  - 所有客户端同步
- **验证点:**
  - 没有页面刷新的情况下恢复

#### TC-AGENT-006: Agent 撤销注册
- **分类:** 身份管理
- **优先级:** P1
- **复杂度:** 低
- **前置条件:** Agent 已注册在线
- **步骤:**
  1. Agent 调用 `agent_unregister`
  2. 验证 Agent 从列表移除
  3. SSE 广播 agent 移除事件
  4. 验证所有客户端的 Agent 状态栏中不再显示该 Agent
- **预期输出:**
  - Agent 完全从 UI 消失
  - 其他 Agent 能看到该变更
- **验证点:**
  - acb-agent-status-item 从 DOM 移除

#### TC-AGENT-007: Agent 活跃度指示器（typing status）
- **分类:** 交互反馈
- **优先级:** P1
- **复杂度:** 中
- **前置条件:** Agent 在 compose 框输入
- **步骤:**
  1. Agent A 在输入框开始输入
  2. 调用 `agent_set_typing` (is_typing=true)
  3. 验证其他客户端看到 "Agent A is typing..." 提示
  4. Agent A 发送消息或 5 秒无操作
  5. 调用 `agent_set_typing` (is_typing=false)
  6. 验证 typing 提示消失
- **预期输出:**
  - typing 状态实时显示在消息列表上方
  - 状态变更 < 500ms 延迟
- **验证点:**
  - `#typing-indicator` 文本显示 Agent 名称

#### TC-AGENT-008: Agent 并发操作（多 Agent 同时操作）
- **分类:** 并发控制
- **优先级:** P1
- **复杂度:** 高
- **前置条件:** 3+ Agents 在线
- **前置条件准备:**
  ```python
  # 伪代码
  agent_a.send_message("msg A1")
  agent_b.send_message("msg B1")  # 同时发送，不等 A 完成
  agent_c.send_message("msg C1")  # 同时发送
  ```
- **步骤:**
  1. 3 个 Agent 同时发送消息
  2. 验证所有消息都收到
  3. 验证消息顺序由时间戳和 seq 决定
  4. 验证每个 Agent 的状态更新不相互干扰
- **预期输出:**
  - 3 条消息全部显示
  - seq 号正确递增
  - 无消息丢失
  - Agent 状态不混乱
- **验证点:**
  - 消息计数 = 3
  - seq 号 [101, 102, 103] (或类似)

---

### 🟡 P2 - UI 状态管理与主题切换 (10 cases)

#### TC-UI-001: 主题切换 (dark/light)
- **分类:** 主题
- **优先级:** P2
- **复杂度:** 低
- **前置条件:** 页面加载
- **步骤:**
  1. 注意初始主题（默认 dark）
  2. 点击"主题切换"按钮 (#btn-theme-toggle)
  3. 验证 body 的 `data-theme` 属性改变为 "light"
  4. 验证 CSS 变量应用正确（背景、文字颜色变化）
  5. 再次点击切换回 dark
- **预期输出:**
  - `body.data-theme` === "light"
  - CSS 中 `var(--bg-base)` 等变量值改变
  - 主题切换立即生效，无闪烁
- **边界情况:**
  - 快速点击多次主题按钮
- **验证点:**
  - 计算样式 (getComputedStyle) 验证颜色变化

#### TC-UI-002: 主题偏好持久化（localStorage）
- **分类:** 状态保存
- **优先级:** P2
- **复杂度:** 低
- **前置条件:** 页面刷新
- **步骤:**
  1. 切换主题为 "light"
  2. 刷新页面
  3. 验证主题仍为 "light"（从 localStorage 恢复）
  4. 清除 localStorage，刷新
  5. 验证恢复为默认 "dark"
- **预期输出:**
  - localStorage 中保存 theme 键值
  - 刷新后状态保持
  - 清除后恢复默认
- **验证点:**
  - `localStorage.getItem("theme")` === "light"

#### TC-UI-003: 设置模态框打开与关闭
- **分类:** 模态框交互
- **优先级:** P2
- **复杂度:** 低
- **前置条件:** 页面加载
- **步骤:**
  1. 点击#btn-settings 按钮
  2. 验证 #settings-modal-overlay 变为可见
  3. 验证模态框内容展示（语言选择、偏好设置等）
  4. 点击 X 关闭或点击背景
  5. 验证模态框隐藏
- **预期输出:**
  - modal-overlay 添加 `visibility: visible`
  - 模态框动画显示
  - 背景变暗
- **验证点:**
  - `#settings-modal-overlay` 的 visibility 属性

#### TC-UI-004: 语言切换（国际化）
- **分类:** 本地化
- **优先级:** P2
- **复杂度:** 中
- **前置条件:** 设置模态框打开
- **步骤:**
  1. 打开设置 → 语言选择
  2. 选择"中文"
  3. 验证 UI 所有标签变为中文
  4. 刷新页面
  5. 验证语言偏好保留
  6. 切换回"English"
- **预期输出:**
  - UI 文本改变为对应语言
  - 按钮标签、menu 项等全部翻译
  - 语言设置持久化
- **边界情况:**
  - 部分字符串未翻译
  - 长翻译文本超出容器
- **验证点:**
  - `document.documentElement.lang` === "zh-CN"

#### TC-UI-005: 侧栏折叠/展开
- **分类:** UI 布局
- **优先级:** P2
- **复杂度:** 低
- **前置条件:** 页面加载
- **步骤:**
  1. 点击侧栏折叠按钮（如果存在）
  2. 验证 #sidebar 宽度变小或隐藏
  3. 验证主区域宽度扩大
  4. 点击展开
  5. 验证侧栏恢复
- **预期输出:**
  - sidebar 宽度变化（例如 300px → 0 或 300px → 80px）
  - main 区域自动调整
  - 无布局闪烁
- **边界情况:**
  - 移动设备宽度下侧栏自动折叠
- **验证点:**
  - `#sidebar` 的 display/width 属性变化

#### TC-UI-006: 响应式布局测试（窗口大小改变）
- **分类:** 响应式设计
- **优先级:** P2
- **复杂度:** 中
- **前置条件:** Playwright 可调整视口大小
- **步骤:**
  1. 初始视口 1440x900
  2. 调整视口为 768x1024 (平板)
  3. 验证布局重排，侧栏可能隐藏
  4. 验证消息列表适应宽度
  5. 调整为 375x667 (手机)
  6. 验证竖屏布局正确
- **预期输出:**
  - 各断点下布局正确
  - 内容不超出视口
  - 所有控件仍可点击
- **边界情况:**
  - 极小屏幕 (320x480)
  - 超宽屏幕 (2560x1440)
- **验证点:**
  - 无水平滚动条（除非必要）

#### TC-UI-007: 无消息时的空状态反馈
- **分类:** 用户反馈
- **优先级:** P2
- **复杂度:** 低
- **前置条件:** Thread 已选中但无消息
- **步骤:**
  1. 选中一个新创建的空 Thread
  2. 验证消息区域显示 empty-state 占位符
  3. 显示文本："No messages yet" 或类似
  4. 可选：显示输入消息的提示
- **预期输出:**
  - empty-state 组件可见
  - 文本清晰可读
  - 不影响输入框（compose 仍可用）
- **验证点:**
  - `#messages .empty-state.visible` 存在

#### TC-UI-008: 消息加载状态指示（loading-history）
- **分类:** 反馈
- **优先级:** P2
- **复杂度:** 低
- **前置条件:** 切换 Thread 需要加载消息
- **步骤:**
  1. 点击另一个 Thread
  2. 验证消息列表显示"加载中..."或加载动画
  3. 验证消息列表 DOM 元素添加 `.loading-history` 类
  4. 消息加载完成后移除 .loading-history 类
- **预期输出:**
  - 加载中显示动画/钻石/加载符号
  - 消息显示时无淡入动画（loading-history 状态禁用）
- **验证点:**
  - `#messages.loading-history` 存在/消失

#### TC-UI-009: 消息通知与未读标记
- **分类:** 通知管理
- **优先级:** P2
- **复杂度:** 中
- **前置条件:** 有新消息推送
- **步骤:**
  1. 当前在 Thread A，有新消息推送到 Thread B
  2. 验证 Thread B 的 thread-item 显示未读标记（通常是红点或数字）
  3. 点击 Thread B 查看消息
  4. 验证未读标记消失
- **预期输出:**
  - 未读消息数显示在 thread-item
  - 查看消息后标记清除
- **边界情况:**
  - 多个 Thread 同时有未读
  - 未读消息数 > 99
- **验证点:**
  - `thread-item` 中的 unread count 元素

#### TC-UI-010: 网络状态指示器（离线/在线）
- **分类:** 连接状态
- **优先级:** P2
- **复杂度:** 中
- **前置条件:** SSE 连接建立
- **步骤:**
  1. 观察状态指示器，正常状态显示"Connected"（绿色）
  2. 模拟网络离线 (DevTools 或 throttle)
  3. 验证状态变为"Reconnecting…"（红色）
  4. 恢复网络
  5. 验证状态恢复为"Connected"（绿色）
- **预期输出:**
  - 状态标签和指示灯同步更新
  - 离线时用户可见警告
- **验证点:**
  - `#status-label.textContent` 变化
  - `#status-dot` 背景色变化

---

### 🟡 P2 - 错误处理与异常恢复 (7 cases)

#### TC-ERR-001: API 超时处理（POST 消息）
- **分类:** 错误处理
- **优先级:** P2
- **复杂度:** 中
- **前置条件:** 模拟 API 缓慢响应
- **步骤:**
  1. 模拟 /api/threads/{id}/messages POST 花费 > 5s
  2. 用户发送消息
  3. 验证 U 在发送时显示加载状态或禁用输入框
  4. 等待超时触发
  5. 验证显示错误提示："Failed to send message"
  6. 提供重试按钮
- **预期输出:**
  - 超时后显示友好的错误消息
  - 用户可重试发送
  - 消息不会重复发送
- **边界情况:**
  - 极长延迟（> 30s）
  - 超时期间用户关闭页面
- **验证点:**
  - 错误通知出现在 UI

#### TC-ERR-002: API 错误响应处理 (4xx, 5xx)
- **分类:** 错误处理
- **优先级:** P2
- **复杂度:** 中
- **前置条件:** 模拟 API 返回错误
- **步骤:**
  1. 模拟 API 返回 500 Internal Server Error
  2. 用户发送消息
  3. 验证显示错误消息："Server error, please try again"
  4. 模拟 API 返回 400 Bad Request（无效输入）
  5. 验证显示具体错误："Invalid message format"
  6. 模拟 API 返回 401 Unauthorized
  7. 验证提示需要重新认证
- **预期输出:**
  - 根据错误类型显示不同的消息
  - 错误消息对用户友好
  - 提供解决方案或重试选项
- **验证点:**
  - 错误通知在 UI 中可见
  - 不影响其他操作

#### TC-ERR-003: 网络中断恢复
- **分类:** 网络弹性
- **优先级:** P2
- **复杂度:** 高
- **前置条件:** SSE 连接建立，网络中断
- **步骤:**
  1. 正常使用时突然网络中断
  2. 用户尝试发送消息
  3. 验证消息发送失败且显示错误
  4. 验证 SSE 自动重连尝试
  5. 网络恢复
  6. SSE 重新连接成功
  7. 验证本地缓存的消息被同步
- **预期输出:**
  - 网络中断时自动检测
  - 重连成功后无需手动刷新
  - 消息保持同步
- **边boundary cases:**
  - 中断时间 > 15 分钟
  - 多次间歇性中断
- **验证点:**
  - SSE connection readyState 恢复为 OPEN

#### TC-ERR-004: 消息发送冲突解决
- **分类:** 并发冲突
- **优先级:** P2
- **复杂度:** 高
- **前置条件:** 多个 Agent 同时操作
- **步骤:**
  1. Agent A 和 B 同时发送消息
  2. 如果消息发送顺序不确定，验证最终 seq 号解决冲突
  3. 验证两条消息都被保存且 seq 正确
  4. 验证消息顺序由 seq 决定，不由发送顺序决定
- **预期输出:**
  - 无消息丢失
  - 无错误 (409 Conflict) 返回用户
  - seq 号不重复
- **验证点:**
  - 消息数 = 2
  - seq 单调递增

#### TC-ERR-005: Thread 删除时的清理
- **分类:** 数据一致性
- **优先级:** P2
- **复杂度:** 中
- **前置条件:** Thread 被删除或存档
- **步骤:**
  1. 选中 Thread A
  2. 删除 Thread A
  3. 验证 UI 中 thread-item 移除
  4. 验证消息列表清空或隐藏
  5. 验证状态栏更新
  6. 验证不会有孤立的消息显示
- **预期输出:**
  - Thread 删除时 UI 正确清理
  - 不存留过期的 DOM 元素
  - 无内存泄漏
- **验证点:**
  - thread-item 从 thread-pane 移除
  - messages 容器清空

#### TC-ERR-006: 无效的用户输入处理
- **分类:** 输入验证
- **优先级:** P2
- **复杂度:** 低
- **前置条件:** compose-shell 输入框获得焦点
- **步骤:**
  1. 输入空消息并尝试发送
  2. 验证发送被拒绝，显示 "Message cannot be empty"
  3. 输入超长消息（> 10,000 字符）
  4. 验证显示警告或截断
  5. 输入包含脚本的消息 `<script>alert('xss')</script>`
  6. 验证脚本被转义显示为文本，不执行
- **预期输出:**
  - 空消息不发送
  - 长消息被限制或警告
  - XSS 攻击被防止（内容转义）
- **验证点:**
  - compose-shell 禁用发送按钮（空消息时）
  - 消息显示时 HTML 被转义

#### TC-ERR-007: 使用过期的 token/session
- **分类:** 认证
- **优先级:** P2
- **复杂度:** 跳过（如果前端无 token）
- **前置条件:** Agent token 过期
- **步骤:**
  1. Agent 的 token 过期
  2. 尝试发送消息或进行操作
  3. 验证 API 返回 401 Unauthorized
  4. 验证显示 "Session expired, please re-login"
  5. 提供重新注册的选项
- **预期输出:**
  - 用户不会陷入未认证状态
  - 清晰的错误消息和恢复方案
- **验证点:**
  - 提示消息显示

---

### 🟢 P3 - 边界情况与特殊场景 (5 cases)

#### TC-EDGE-001: 数字 ID 与字符串 ID 混合（防护性测试）
- **分类:** 数据类型安全
- **优先级:** P3
- **复杂度:** 低
- **前置条件:** 已有烟雾测试 test_numeric_agent_and_author_does_not_crash_js
- **步骤:**
  1. API 返回数字类型的 agent_id, author_id, seq（如 111, 222, 333）
  2. 验证 JavaScript 不崩溃
  3. 验证排序函数（如 localeCompare）处理数字正确
  4. 验证消息显示不异常
- **预期输出:**
  - 无 TypeError (a.localeCompare is not a function)
  - 数字 ID 被强制转换为字符串并正确处理
  - UI 正常显示
- **验证点:**
  - 浏览器控制台无错误
  - 消息列表正常显示

#### TC-EDGE-002: 超大消息内容（> 100KB）
- **分类:** 容量处理
- **优先级:** P3
- **复杂度:** 中
- **前置条件:** 消息可为任意大小
- **步骤:**
  1. 生成 100KB 的消息内容
  2. 发送消息
  3. 验证消息显示正确
  4. 验证页面性能不显著下降
  5. 测试 1MB 消息（如果支持）
- **预期输出:**
  - 消息显示完整
  - 渲染时间 < 1s
  - 内存使用合理
- **边界情况:**
  - 消息为纯文本 vs. 包含 HTML
- **验证点:**
  - 消息内容长度正确

#### TC-EDGE-003: 特殊字符与多语言支持
- **分类:** 国际化
- **优先级:** P3
- **复杂度:** 低
- **前置条件:** 消息可包含任意字符
- **步骤:**
  1. 发送包含 emoji 的消息：👍🎉🚀
  2. 发送包含中文的消息：你好，世界
  3. 发送包含 RTL 文本的消息：مرحبا العالم
  4. 验证所有内容显示正确
  5. 验证排序不受影响
- **预期输出:**
  - emoji 正确显示
  - 中文显示正常
  - RTL 文本从右到左显示
  - 无乱码
- **验证点:**
  - 消息内容准确无误

#### TC-EDGE-004: Thread 和消息的极限数量
- **分类:** 容量测试
- **优先级:** P3
- **复杂度:** 中
- **前置条件:** 测试环境
- **步骤:**
  1. 创建 100+ 个 Thread
  2. 验证线程列表加载和滚动性能
  3. 在一个 Thread 中发送 1000+ 条消息
  4. 验证消息列表不崩溃
  5. 验证滚动和搜索仍可用
- **预期输出:**
  - 列表可滚动
  - 特定 Thread 可加载 1000+ 消息？（根据 API 限制，可能限制为 300）
  - 性能可接受（< 3s 加载）
- **验证点:**
  - 无 JavaScript 堆溢出错误

#### TC-EDGE-005: 连续刷新/F5 操作
- **分类:** 稳定性
- **优先级:** P3
- **复杂度:** 低
- **前置条件:** 页面正在使用
- **步骤:**
  1. 连续按 F5 刷新页面 10 次
  2. 验证每次刷新都能正确加载数据
  3. 验证状态正确恢复
  4. 验证 SSE 连接正确重建
- **预期输出:**
  - 无错误或异常
  - 最终状态与刷新前一致
- **验证点:**
  - 消息和 Agent 列表最终一致

---

## 测试数据准备

### 1. Thread 测试数据集

```python
TEST_THREADS = [
    {
        "id": "thread-001",
        "topic": "Test Thread - Normal",
        "status": "discuss",
        "messages_count": 50,
        "description": "常规线程，包含多条消息"
    },
    {
        "id": "thread-002", 
        "topic": "Test Thread - Empty",
        "status": "discuss",
        "messages_count": 0,
        "description": "空线程，用于测试 empty-state"
    },
    {
        "id": "thread-003",
        "topic": "Test Thread - Large",
        "status": "discuss",
        "messages_count": 500,
        "description": "大型线程，性能测试用"
    },
    {
        "id": "thread-004",
        "topic": "Test Thread - Archived",
        "status": "archived",
        "messages_count": 20,
        "description": "已归档线程"
    },
]
```

### 2. 消息测试数据集

```python
TEST_MESSAGES = [
    {"content": "Normal message", "role": "user"},
    {"content": "Emoji test 🎉👍🚀", "role": "user"},
    {"content": "Special chars: <>&\"'", "role": "user"},
    {"content": "Multi-line\nmessage\nwith\nbreaks", "role": "assistant"},
    {"content": "Long message " * 1000, "role": "user"},  # > 10KB
    {"content": "中文消息测试", "role": "user"},
    {"content": "مرحبا العالم", "role": "assistant"},
]
```

### 3. Agent 测试数据集

```python
TEST_AGENTS = [
    {"id": "agent-001", "name": "Test Agent A", "is_online": True},
    {"id": "agent-002", "name": "Test Agent B", "is_online": False},
    {"id": "agent-003", "name": "Test Agent C", "is_online": True},
]
```

---

## Mock/Stub 策略

### Playwright Route Interception

```javascript
// 示例：Mock API 响应
page.route("**/api/threads", async (route) => {
  await route.fulfill({
    json: TEST_THREADS,
    status: 200,
  });
});

page.route("**/api/threads/*/messages", async (route) => {
  await route.fulfill({
    json: TEST_MESSAGES,
    status: 200,
  });
});
```

### SSE 事件模拟

```javascript
// 伪代码：注入虚假 SSE 事件
page.evaluate(() => {
  const fakeMessage = new MessageEvent("message", {
    data: JSON.stringify({
      type: "msg.new",
      payload: { thread_id: "...", seq: 101 }
    })
  });
  eventSource.dispatchEvent(fakeMessage);
});
```

### 网络限流模拟

```python
# Playwright 网络限流 API
page.route("**/*", (route) => {
  page.throttle({"latency": 5000});  # 5秒延迟
  route.continue();
});
```

---

## 执行环境需求

### 软件需求
- Python >= 3.9
- Playwright >= 1.40
- pytest >= 7.0
- httpx >= 0.24

### 硬件需求
- RAM >= 4GB
- 磁盘空间 >= 1GB
- 网络连接：本地网络

### 服务依赖
- AgentChatBus 服务运行在 http://127.0.0.1:39766
- PostgreSQL/SQLite 数据库可用
- SSE `/events` 端点可访问

### 测试执行时间
- 烟雾测试 (7 cases): ~2-3 分钟
- P0 测试 (18 cases): ~10-15 分钟
- P1 测试 (20 cases): ~15-20 分钟
- P2 测试 (17 cases): ~20-25 分钟
- P3 测试 (5 cases): ~10-15 分钟
- **总耗时:** ~1-2 小时（取决于网络和硬件）

---

## 验收标准

### 1. 覆盖率要求
- **代码覆盖率:** ≥ 60%（初期目标）
- **功能覆盖率:** ≥ 85%（关键功能）
- **缺陷检出率:** > 80%（基于历史缺陷数据）

### 2. 性能基线
- **页面加载:** < 3 秒
- **消息显示延迟:** < 500ms（SSE 推送后）
- **组件交互响应:** < 200ms
- **高频事件处理:** 能处理 10+ 消息/秒

### 3. 质量标准
- **零关键缺陷：** 不允许在 P0 测试中有失败
- **最多 3 个 P1 缺陷：** 可在下一个版本修复
- **P2/P3 缺陷：** 可推迟修复
- **代码审查审批率：** 100%（所有测试代码需审查）

### 4. 回归标准
- **烟雾测试通过率：** 100%
- **已知缺陷白名单：** 需文档化和跟踪

---

**下一步：** 审查通过后，可进行 Phase 3（生成具体的测试用例代码实现）。
